<!doctype html>
<html lang="fa" dir="rtl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Team5 Recommendation UI (React)</title>
    <link rel="stylesheet" href="../../static/team5/styles/style.css" />
    <link href="https://fonts.googleapis.com/css2?family=Vazirmatn:wght@100..900&display=swap" rel="stylesheet" />
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body>
    <div id="root"></div>
    <script type="text/babel">
      const { useEffect, useMemo, useRef, useState } = React;

      const API_BASE = window.location.port === "8000" ? "" : "http://127.0.0.1:8000";
      const FEEDBACK_ACTIONS = new Set(["popular", "personalized", "nearest"]);

      const PLACE_IMAGES = {
        "tehran-milad-tower": "../../static/team5/styles/imgs/milad.jpg",
        "tehran-azadi-tower": "../../static/team5/styles/imgs/azadi.jpg",
        "tehran-golestan-palace": "../../static/team5/styles/imgs/golestan.jpg",
        "isfahan-naqsh-jahan": "../../static/team5/styles/imgs/naqhshe.jpg",
        "isfahan-si-o-se-pol": "../../static/team5/styles/imgs/siosepol.jpg",
        "shiraz-hafezieh": "../../static/team5/styles/imgs/hafez.jpg",
        "shiraz-pasargadae": "../../static/team5/styles/imgs/pasargad.jpg",
        "tabriz-arg": "../../static/team5/styles/imgs/elgoli.jpg",
        "mashhad-haram": "../../static/team5/styles/imgs/haram.jpg",
      };

      const ACTION_LABELS = {
        users: "Users",
        cities: "Cities",
        places: "Places",
        media: "Media",
        popular: "Popular",
        nearest: "Your Nearest",
        personalized: "Personalized",
        interests: "Interests",
        "user-ratings": "User Ratings",
      };

      const REASON_LABELS = {
        high_user_rating: "Ø¨Ù‡ Ø®Ø§Ø·Ø± Ø§Ù…ØªÛŒØ§Ø² Ø¨Ø§Ù„Ø§ÛŒ Ú©Ø§Ø±Ø¨Ø±",
        your_nearest: "Ù†Ø²Ø¯ÛŒÚ©â€ŒØªØ±ÛŒÙ† Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ Ø¨Ø±Ø§Ø³Ø§Ø³ Ù…ÙˆÙ‚Ø¹ÛŒØª Ø´Ù…Ø§",
        ml_personalized: "Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ Ø´Ø®ØµÛŒâ€ŒØ³Ø§Ø²ÛŒâ€ŒØ´Ø¯Ù‡ Ø¨Ø§ Ù…Ø¯Ù„ ML",
        similar_topic: "Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ Ù…Ø´Ø§Ø¨Ù‡ Ù…ÙˆØ¶ÙˆØ¹ÛŒ",
        same_city: "Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ Ù…Ø´Ø§Ø¨Ù‡ Ø¯Ø± Ù‡Ù…Ø§Ù† Ø´Ù‡Ø±",
        similar: "Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ Ù…Ø´Ø§Ø¨Ù‡",
      };

      function api(path) {
        return `${API_BASE}${path}`;
      }

      function App() {
        const [userId, setUserId] = useState("");
        const [cityId, setCityId] = useState("tehran");
        const [limit, setLimit] = useState(5);
        const [users, setUsers] = useState([]);
        const [jsonOutput, setJsonOutput] = useState("Ø¯Ø± Ø­Ø§Ù„ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ...");
        const [cardsPayload, setCardsPayload] = useState(null);
        const [lastAction, setLastAction] = useState("popular");
        const [placesById, setPlacesById] = useState({});
        const [citiesById, setCitiesById] = useState({});
        const [isTraining, setIsTraining] = useState(false);
        const [trainingMessage, setTrainingMessage] = useState("");
        const [showFeedbackPrompt, setShowFeedbackPrompt] = useState(false);
        const [isFeedbackMounted, setIsFeedbackMounted] = useState(false);
        const [isFeedbackExiting, setIsFeedbackExiting] = useState(false);
        const [feedbackMessage, setFeedbackMessage] = useState("");
        const [shineCards, setShineCards] = useState(false);
        const [dislikeFlashCards, setDislikeFlashCards] = useState(false);
        const [isSubmittingFeedback, setIsSubmittingFeedback] = useState(false);
        const [isFeedbackLocked, setIsFeedbackLocked] = useState(false);
        const [feedbackSubmitted, setFeedbackSubmitted] = useState(false);
        const feedbackHideTimerRef = useRef(null);

        const safeLimit = useMemo(() => {
          const parsed = Number(limit);
          if (!Number.isFinite(parsed)) return 5;
          return Math.min(100, Math.max(1, Math.floor(parsed)));
        }, [limit]);

        const shownMediaIds = useMemo(() => extractShownMediaIds(cardsPayload), [cardsPayload]);
        const canShowFeedback = FEEDBACK_ACTIONS.has(lastAction) && shownMediaIds.length > 0 && !feedbackSubmitted;

        useEffect(() => {
          loadReferenceData();
          loadUsers();
          callAction("popular");
        }, []);

        useEffect(() => {
          return () => {
            if (feedbackHideTimerRef.current) {
              window.clearTimeout(feedbackHideTimerRef.current);
            }
          };
        }, []);

        useEffect(() => {
          setFeedbackMessage("");
          let timerId;
          let unmountId;

          if (canShowFeedback) {
            setIsFeedbackMounted(true);
            setIsFeedbackExiting(false);
            setShowFeedbackPrompt(false);
            timerId = window.setTimeout(() => setShowFeedbackPrompt(true), 3000);
          } else if (isFeedbackMounted) {
            setShowFeedbackPrompt(false);
            setIsFeedbackExiting(true);
            unmountId = window.setTimeout(() => {
              setIsFeedbackMounted(false);
              setIsFeedbackExiting(false);
            }, 360);
          }

          return () => {
            if (timerId) window.clearTimeout(timerId);
            if (unmountId) window.clearTimeout(unmountId);
          };
        }, [canShowFeedback, lastAction, jsonOutput]);

        async function loadReferenceData() {
          try {
            const res = await fetch(api("/team5/api/cities/"), { credentials: "same-origin" });
            const cities = await res.json();
            if (!Array.isArray(cities)) return;

            const cityMap = {};
            for (const city of cities) {
              cityMap[city.cityId] = city.cityName;
            }
            setCitiesById(cityMap);

            const placeMap = {};
            await Promise.all(
              cities.map(async (city) => {
                try {
                  const placesRes = await fetch(api(`/team5/api/places/city/${encodeURIComponent(city.cityId)}/`), {
                    credentials: "same-origin",
                  });
                  const places = await placesRes.json();
                  if (Array.isArray(places)) {
                    for (const place of places) {
                      placeMap[place.placeId] = place;
                    }
                  }
                } catch (_) {}
              })
            );
            setPlacesById(placeMap);
          } catch (_) {}
        }

        async function loadUsers() {
          const endpoint = api("/team5/api/users/");
          try {
            const res = await fetch(endpoint, { credentials: "same-origin" });
            const data = await res.json();
            const list = Array.isArray(data.items) ? data.items : [];
            setUsers(list);
            if (!userId && list.length) setUserId(list[0].userId);
          } catch (error) {
            setJsonOutput(JSON.stringify({ status: "network_error", endpoint, error: String(error) }, null, 2));
          }
        }

        function endpointByAction(action) {
          const encodedUser = encodeURIComponent(userId.trim());
          const encodedCity = encodeURIComponent(cityId.trim());
          switch (action) {
            case "cities":
              return api("/team5/api/cities/");
            case "places":
              return api(`/team5/api/places/city/${encodedCity}/`);
            case "media":
              return api(`/team5/api/media/?userId=${encodedUser}`);
            case "users":
              return api("/team5/api/users/");
            case "user-ratings":
              return api(`/team5/api/users/${encodedUser}/ratings/`);
            case "popular":
              return api(`/team5/api/recommendations/popular/?limit=${safeLimit}&userId=${encodedUser}`);
            case "nearest":
              return api(`/team5/api/recommendations/nearest/?limit=${safeLimit}&cityId=${encodedCity}&userId=${encodedUser}`);
            case "personalized":
              return api(`/team5/api/recommendations/personalized/?userId=${encodedUser}&limit=${safeLimit}`);
            case "interests":
              return api(`/team5/api/users/${encodedUser}/interests/`);
            case "ping":
              return api("/team5/ping/");
            default:
              return null;
          }
        }

        async function callAction(action) {
          const endpoint = endpointByAction(action);
          if (!endpoint) return;
          setLastAction(action);
          if (feedbackHideTimerRef.current) {
            window.clearTimeout(feedbackHideTimerRef.current);
            feedbackHideTimerRef.current = null;
          }
          setIsFeedbackLocked(false);
          if (FEEDBACK_ACTIONS.has(action)) {
            setFeedbackSubmitted(false);
          } else {
            setFeedbackSubmitted(true);
          }
          setShineCards(false);
          setDislikeFlashCards(false);
          try {
            const res = await fetch(endpoint, { credentials: "same-origin" });
            const text = await res.text();
            let payload = text;
            try {
              payload = JSON.parse(text);
            } catch (_) {}
            setCardsPayload(payload);
            setJsonOutput(JSON.stringify({ status: res.status, endpoint, data: payload }, null, 2));
          } catch (error) {
            setCardsPayload(null);
            setJsonOutput(JSON.stringify({ status: "network_error", endpoint, error: String(error) }, null, 2));
          }
        }

        async function trainModel() {
          setIsTraining(true);
          setTrainingMessage("Training started...");
          const endpoint = api("/team5/api/train");
          try {
            const res = await fetch(endpoint, { method: "POST", credentials: "same-origin" });
            const raw = await res.text();
            let payload;
            try {
              payload = JSON.parse(raw);
            } catch (_) {
              throw new Error(`Non-JSON response: ${raw.slice(0, 140)}`);
            }
            const statusRes = await fetch(api("/team5/api/ml/status"), { credentials: "same-origin" });
            const statusPayload = await statusRes.json();
            setTrainingMessage(`Train: ${payload.trained ? "OK" : "FAILED"} | modelsReady=${statusPayload.modelsReady} | mediaSamples=${statusPayload.mediaRatingsSamples}`);
            setJsonOutput(JSON.stringify({ status: res.status, endpoint, train: payload, mlStatus: statusPayload }, null, 2));
          } catch (error) {
            setTrainingMessage(`Train error: ${String(error)}`);
          } finally {
            setIsTraining(false);
          }
        }

        async function submitFeedback(liked) {
          if (!userId.trim()) {
            setFeedbackMessage("Ø§Ø¨ØªØ¯Ø§ ÛŒÚ© Ú©Ø§Ø±Ø¨Ø± Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†.");
            return;
          }
          if (!canShowFeedback) {
            setFeedbackMessage("ÙØ¹Ù„Ø§ Ø¢ÛŒØªÙ…ÛŒ Ø¨Ø±Ø§ÛŒ Ø«Ø¨Øª ÙÛŒØ¯Ø¨Ú© ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯.");
            return;
          }
          setIsSubmittingFeedback(true);
          try {
            const endpoint = api("/team5/api/recommendations/feedback/");
            const res = await fetch(endpoint, {
              method: "POST",
              credentials: "same-origin",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                userId: userId.trim(),
                action: lastAction,
                liked,
                shownMediaIds: shownMediaIds,
              }),
            });
            const payload = await res.json();
            if (!res.ok) {
              setFeedbackMessage(payload.detail || "Ø«Ø¨Øª ÙÛŒØ¯Ø¨Ú© Ù†Ø§Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯.");
              return;
            }
            setFeedbackMessage(
              liked
                ? "Ù…Ù…Ù†ÙˆÙ† Ø§Ø² ÙÛŒØ¯Ø¨Ú© Ù…Ø«Ø¨ØªØŒ Ø®ÙˆØ´Ø­Ø§Ù„ÛŒÙ… Ø®ÙˆØ´Øª Ø§ÙˆÙ…Ø¯Ù‡."
                : "Ø¨Ø±Ø§ÛŒ Ø¯ÛŒØ¯Ù† Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯Ù‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯ØŒ Ù…Ø¬Ø¯Ø¯ ÙˆØ§Ø±Ø¯ Ù‡Ù…ÛŒÙ† ØµÙØ­Ù‡ Ø´ÙˆÛŒØ¯."
            );
            if (liked) {
              setShineCards(true);
              window.setTimeout(() => setShineCards(false), 2500);
            } else {
              setDislikeFlashCards(true);
              window.setTimeout(() => setDislikeFlashCards(false), 1700);
            }
            setIsFeedbackLocked(true);
            if (feedbackHideTimerRef.current) {
              window.clearTimeout(feedbackHideTimerRef.current);
            }
            feedbackHideTimerRef.current = window.setTimeout(() => {
              setFeedbackSubmitted(true);
              setShowFeedbackPrompt(false);
              setIsFeedbackLocked(false);
              feedbackHideTimerRef.current = null;
            }, 2000);
          } catch (error) {
            setFeedbackMessage(`Ø®Ø·Ø§ Ø¯Ø± Ø«Ø¨Øª ÙÛŒØ¯Ø¨Ú©: ${String(error)}`);
          } finally {
            setIsSubmittingFeedback(false);
          }
        }

        return (
          <main className="container">
            <header className="page-header page-header-modern">
              <h1>Team5 Recommendation Service</h1>
              <p>Ù†Ø³Ø®Ù‡ React - Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯Ù‡Ø§ÛŒ Popular, Personalized Ùˆ Your Nearest Ø¨Ø±Ø§Ø³Ø§Ø³ IP</p>
            </header>

            <section className="panel">
              <h2>ØªÙ†Ø¸ÛŒÙ…Ø§Øª</h2>
              <div className="form-grid">
                <label>
                  Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ø§Ø±Ø¨Ø±
                  <select value={userId} onChange={(e) => setUserId(e.target.value)}>
                    <option value="">-- Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù† --</option>
                    {users.map((user) => {
                      const fullName = `${user.firstName || ""} ${user.lastName || ""}`.trim();
                      return (
                        <option key={user.userId} value={user.userId}>
                          {fullName ? `${fullName} - ${user.email}` : `${user.email} - ${user.userId}`}
                        </option>
                      );
                    })}
                  </select>
                </label>
                <label>
                  User ID
                  <input value={userId} onChange={(e) => setUserId(e.target.value)} placeholder="UUID user id" />
                </label>
                <label>
                  City ID
                  <input value={cityId} onChange={(e) => setCityId(e.target.value)} placeholder="tehran" />
                </label>
                <label>
                  Limit
                  <input type="number" min="1" max="100" value={limit} onChange={(e) => setLimit(e.target.value)} />
                </label>
              </div>
            </section>

            <section className="panel">
              <h2>Ø§Ú©Ø´Ù†â€ŒÙ‡Ø§</h2>
              <div className="actions">
                <button type="button" onClick={loadUsers}>Load Users Dropdown</button>
                <button type="button" onClick={trainModel} disabled={isTraining}>
                  {isTraining ? "Training..." : "Train Model"}
                </button>
                {Object.keys(ACTION_LABELS).map((action) => (
                  <button key={action} type="button" onClick={() => callAction(action)}>
                    {ACTION_LABELS[action]}
                  </button>
                ))}
              </div>
              {trainingMessage ? <p className="reason">{trainingMessage}</p> : null}
            </section>

            <section className="panel">
              <h2>Ø®Ø±ÙˆØ¬ÛŒ JSON</h2>
              <pre>{jsonOutput}</pre>
            </section>

            <section className="panel">
              <h2>Ù†Ù…Ø§ÛŒØ´ Ú©Ø§Ø±Øªâ€ŒÙ‡Ø§</h2>
              <CardsView payload={cardsPayload} lastAction={lastAction} placesById={placesById} citiesById={citiesById} shineCards={shineCards} dislikeFlashCards={dislikeFlashCards} />
            </section>

            {isFeedbackMounted ? (
              <section className={`feedback-widget ${showFeedbackPrompt ? "show" : ""} ${isFeedbackExiting ? "hide" : ""}`}>
                <p className="feedback-title">Ø§ÛŒÙ† Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯Ù‡Ø§ Ø¨Ø±Ø§Øª Ù…ÙÛŒØ¯ Ø¨ÙˆØ¯ØŸ</p>
                <div className="feedback-actions">
                  <button type="button" className="feedback-btn like" disabled={isSubmittingFeedback || isFeedbackLocked} onClick={() => submitFeedback(true)}>
                    ğŸ‘ Ù¾Ø³Ù†Ø¯ÛŒØ¯Ù…
                  </button>
                  <button type="button" className="feedback-btn dislike" disabled={isSubmittingFeedback || isFeedbackLocked} onClick={() => submitFeedback(false)}>
                    ğŸ‘ Ù†Ù¾Ø³Ù†Ø¯ÛŒØ¯Ù…
                  </button>
                </div>
                {feedbackMessage ? <p className="feedback-message">{feedbackMessage}</p> : null}
              </section>
            ) : null}

            <section className="panel panel-note">
              <h2>Ø±Ø§Ù‡Ù†Ù…Ø§</h2>
              <ul>
                <li>Ø¨Ø±Ø§ÛŒ Personalized Ùˆ Interests Ù…Ù‚Ø¯Ø§Ø± <code>User ID</code> Ø±Ø§ ØªÙ†Ø¸ÛŒÙ… Ú©Ù†.</li>
                <li>Ø¯Ø± <code>Your Nearest</code> Ø§Ø¨ØªØ¯Ø§ IP Ø¨Ø±Ø±Ø³ÛŒ Ù…ÛŒâ€ŒØ´ÙˆØ¯Ø› Ø§Ú¯Ø± resolve Ù†Ø´Ø¯ Ø§Ø² <code>City ID</code> Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.</li>
                <li>Ø¨Ø±Ø§ÛŒ Places by City Ù…Ù‚Ø¯Ø§Ø± <code>City ID</code> Ø±Ø§ ØªÙ†Ø¸ÛŒÙ… Ú©Ù† (Ù…Ø«Ù„: tehran, shiraz).</li>
              </ul>
            </section>

            <div className="footer">
              <a href="/" className="back-btn">Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ø¯Ø§Ø´Ø¨ÙˆØ±Ø¯ Ø§ØµÙ„ÛŒ</a>
            </div>
          </main>
        );
      }

      function CardsView({ payload, lastAction, placesById, citiesById, shineCards, dislikeFlashCards }) {
        const sections = [];
        if (Array.isArray(payload)) {
          sections.push({ title: ACTION_LABELS[lastAction] || "Items", items: payload });
        } else if (payload && typeof payload === "object") {
          if (Array.isArray(payload.highRatedItems)) sections.push({ title: "Personalized", items: payload.highRatedItems });
          if (Array.isArray(payload.similarItems)) sections.push({ title: "Similars", items: payload.similarItems });
          if (Array.isArray(payload.ratedHigh)) sections.push({ title: "Rated High", items: payload.ratedHigh });
          if (Array.isArray(payload.ratedLow)) sections.push({ title: "Rated Low", items: payload.ratedLow });
          if (Array.isArray(payload.items) && !sections.length) sections.push({ title: ACTION_LABELS[lastAction] || "Items", items: payload.items });
        }

        const hasAny = sections.some((sec) => sec.items && sec.items.length);
        if (!hasAny) return <p className="empty">Ø¯Ø§Ø¯Ù‡â€ŒØ§ÛŒ Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§ÛŒØ´ Ú©Ø§Ø±Øª ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯.</p>;

        return (
          <>
            {sections.map((section) => (
              <React.Fragment key={section.title}>
                <h3 className="section-title">{section.title}</h3>
                <div className="cards">
                  {section.items.map((item, index) => (
                    <MediaCard key={`${item.mediaId || item.placeId || "item"}-${index}`} item={item} place={placesById[item.placeId || item.media?.placeId]} citiesById={citiesById} shineCards={shineCards} dislikeFlashCards={dislikeFlashCards} />
                  ))}
                </div>
              </React.Fragment>
            ))}
          </>
        );
      }

      function MediaCard({ item, place, citiesById, shineCards, dislikeFlashCards }) {
        const placeId = item.placeId || item.media?.placeId || "";
        const cityName = place ? citiesById[place.cityId] || place.cityId : "-";
        const placeName = place?.placeName || item.placeName || item.title || item.mediaId || "Content";
        const avgRate = Number(item.overallRate ?? item.media?.overallRate);
        const userRate = Number(item.userRate ?? item.rate);
        const avgText = Number.isFinite(avgRate) ? avgRate.toFixed(2) : "-";
        const userText = Number.isFinite(userRate) ? userRate.toFixed(1) : "-";
        const reason = item.matchReason ? REASON_LABELS[item.matchReason] || item.matchReason : "";
        const image = PLACE_IMAGES[placeId] || `https://source.unsplash.com/800x450/?iran,travel,${encodeURIComponent(placeName)}`;

        return (
          <article className={`card card-modern ${shineCards ? "shine" : ""} ${dislikeFlashCards ? "dislike-flash" : ""}`}>
            <div className="card-image-wrap">
              <img className="card-image" src={image} alt={placeName} loading="lazy" />
              {reason ? <span className="chip">{reason}</span> : null}
            </div>
            <div className="card-top">
              <h3 className="place-name">{placeName}</h3>
              <p className="city-name">{cityName}</p>
            </div>
            <div className="stats">
              <div className="stat">
                <span className="label">Ù…ÛŒØ§Ù†Ú¯ÛŒÙ†</span>
                <span className="value">{avgText}</span>
              </div>
              <div className="stat">
                <span className="label">Ø§Ù…ØªÛŒØ§Ø² Ú©Ø§Ø±Ø¨Ø±</span>
                <span className="value user">{userText}</span>
              </div>
            </div>
          </article>
        );
      }

      function extractShownMediaIds(payload) {
        if (!payload || typeof payload !== "object") return [];
        const ids = [];
        const pushId = (value) => {
          const text = String(value || "").trim();
          if (text) ids.push(text);
        };

        if (Array.isArray(payload.items)) payload.items.forEach((item) => pushId(item?.mediaId));
        if (Array.isArray(payload.highRatedItems)) payload.highRatedItems.forEach((item) => pushId(item?.mediaId));
        if (Array.isArray(payload.similarItems)) payload.similarItems.forEach((item) => pushId(item?.mediaId));
        if (Array.isArray(payload.ratedHigh)) payload.ratedHigh.forEach((item) => pushId(item?.mediaId));
        if (Array.isArray(payload.ratedLow)) payload.ratedLow.forEach((item) => pushId(item?.mediaId));

        return [...new Set(ids)];
      }

      ReactDOM.createRoot(document.getElementById("root")).render(<App />);
    </script>
  </body>
</html>
